%06.11.2024
\section{Digital Signatures}

We have two participants: Alice and~Bob.
Additionally, there exists an~adversary, Charlie.
All communication between Alice and~Bob is~routed through Charlie.
Charlie has the~capability to~read, modify, and send fake messages, among other actions.
Alice intends to~sign a~message and~transmit it to~Bob.
Consequently, it must be~ensured that no entity can forge Alice's signature (even if they've seen a lot of signed messages), and that any recipient can verify that the message was indeed signed by Alice.

\begin{definition}
	A~Digital Signature Scheme~(DSS) consists~of three algorithms:
	\begin{itemize}
		\item $G \colon (1^{n}, r_g) \to (s, v)$~(key generation producing a~secret key~$s$ and a~public verifier~$v$),
		\item $S \colon (s, \msg, r_s) \to \sign$~(signing algorithm generating a~signature $\sign$ for message~$\msg$),
		\item $V \colon (v, \msg, \sign) \to \{0, 1\}$~(verification algorithm that outputs~$1$ if~$\sign$ is valid for~$\msg$, and~$0$ otherwise).
	\end{itemize}

	Moreover, the following properties are~satisfied:
	\begin{itemize}
		\item \textbf{Correctness:} For~all messages~$\msg$, it~holds that:
			\[
				\Pr_{r_g}\big[V_v(\msg, S_s(\msg)) = 0\big] = 0.
			\] 

		\item \textbf{Security:} For~any adversary~$A^\bullet$, it~holds that:
			\[
				\Pr\big[A^{S_s}(v) = (\msg, \sign) \colon V(\msg, \sign) = 1\big] < \varepsilon(n),
			\]
			where~$A^{S_s}$ can compel Alice to~sign arbitrary messages, except for the specific message~$\msg$ (utilizing the signing algorithm~$S_s$ as a~black box).
	\end{itemize}
\end{definition}

There exist various adversarial models:
\begin{itemize}
	\item The adversary can request a~signature for each message at most once: $A^{\bullet[1]}$.
	\item The adversary can request a~polynomial number of signatures: $A^{S_s, [l(n)]}$, for some polynomial function~$l(n)$.
	\item The adversary operates in an~unbounded model (general schemes).
\end{itemize}

\begin{exercise}
	Does it matter whether the algorithms~$S$~and~$V$ are~randomized?
\end{exercise}

% \begin{claim}
% 	Using a PRG $G  \colon \{0, 1\}^{n} \to  \{0, 1\}^{n + 1}$.
% 	If someone can invert $G$, then one could also break this PRG. 
% \end{claim}
% \begin{proof}
% 	To distinguish between outputs of $G$ and uniform distribution, one do the following.
% 	We take a preimage of $G$, then say that this string was generated by PRG (it may not). 
% 	Otherwise, say that its uniform.
% \end{proof}
%
% Hence, an existence of PRG implies an existence of owf.

\subsection{One-time bounded DSS}

\begin{scheme}
	Let~$f$ be a~one-way function.
	Let~$m = l(n)$ be a~polynomial.
	Then, for each~$i$ and~$k$, sample~$s_{k}^{i} \gets U_k$~(generated using~$r_g$) and~compute $v_k^{i} = f(s_{k}^{i})$.

	Specifically:
	\[
		G(1^{n}, r_g) = \big((s^{0}_{0}, s^{1}_{0}, \ldots, s^{0}_{m}, s^{1}_{m}), (v^{0}_{0}, v^{1}_{0}, \ldots, v^{0}_{m}, v^{1}_{m})\big).
	\] 
	Note that~$s_{k}^{i}$~and~$v_{k}^{i}$ are strings, not individual bits.
	Using this setup, one can sign a~message $\beta_1 \circ \ldots \circ \beta_m$ as:
	\[
		S_s(\beta_1 \circ \ldots \circ \beta_m) = (s_1^{\beta_1}, \ldots, s_m^{\beta_m}).
	\] 
	To verify a~signature $\sign$ for a~message $\msg$, the~verification algorithm~$V(\msg, \sign)$ checks that, for all~$i \in [m]$, the following holds:
	\[
		f(\sign_i) = v_i^{\beta_i}.
	\]

	Thus, the~tuple $(G, S, V)$ constitutes a~Digital Signature Scheme~(DSS).
\end{scheme}
\begin{lemma}
    This scheme is secure.
\end{lemma}
 
\begin{proof}
  Suppose there exists an adversary \(A^\bullet\) that breaks the given digital signature scheme (DSS) with a non-negligible advantage \(\epsilon\). We will show how to use \(A^\bullet\) to invert the one-way function \(f\) with non-negligible probability, contradicting the one-wayness of \(f\).

  Let \(y\) be an arbitrary value for which we wish to find \(f^{-1}(y)\). We randomly choose an index \(k \in [m]\) and a bit \(b \in \{0,1\}\). Then we generate 
  \[
    G\bigl(1^{n}, r_g\bigr) 
    \;=\; 
    \bigl( (s^{0}_{0}, s^{1}_{0}, \dots, s^{0}_{m}, s^{1}_{m}),\;
           (v^{0}_{0}, v^{1}_{0}, \dots, v^{0}_{m}, v^{1}_{m}) \bigr),
  \]
  but \emph{replace} \(v_{k}^{b}\) with our target value \(y\). In other words, we “hide” \(y\) in one position of the public key.

  We give the adversary \(A^\bullet\) the modified public key \(\{v_{i}^{j}\}\) (where one element \(v_{k}^{b}\) has been replaced by \(y\)) and the corresponding secret key \(\{s_{i}^{j}\}\). The adversary then makes (adaptive) signing queries. Denote by \(M'\) the message (in \(\{0,1\}^m\)) that \(A^\bullet\) asks us to sign at some point.

  Let \(M'_k\) be the \(k\)-th bit of \(M'\).
  - If \(M'_k = b\), we must \textbf{abort}, since we cannot produce a valid signature (the required preimage for \(v_{k}^{b}\) is unknown; it was replaced by \(y\)).
  
  - If \(M'_k \neq b\), we \emph{can} generate a valid signature, because we do know all necessary preimages (including \(s_{k}^{1-b}\)).

  The key observation is that \(A^\bullet\) does not know which index \(k\) we selected or which bit \(b\) we used to “hide” \(y\). Hence the probability that \(A^\bullet\) picks a message \(M'\) with \(M'_k = b\) is \(1/2\), and similarly \(M'_k \neq b\) with probability \(1/2\). Thus, we do not abort with probability \(1/2\).

  Next, assume that the adversary eventually \emph{forges} a signature (which happens with probability at least \(\epsilon\)). A successful forgery must include a correct preimage for one of the public-key elements \(v_{i}^{j}\). If it happens that the forged preimage corresponds to \(v_{k}^{b} = y\), we recover \(f^{-1}(y)\) and succeed in inverting \(f\).

  To estimate the overall probability of success, note the following:

  - We do \emph{not} abort with probability \(1/2\).

  - The adversary forges successfully with probability at least \(\epsilon\).

  - Among the \(2m\) components \(\{v_{i}^j\}\), there is exactly one “special” element \(v_{k}^{b} = y\). The probability that the adversary’s forgery reveals the preimage of \(y\) (i.e., targets precisely \((k,b)\)) is at least \(1/m\).

  Multiplying these factors together, our overall probability of recovering \(f^{-1}(y)\) is at least
  \[
    \frac{1}{2} \;\times\; \epsilon \;\times\; \frac{1}{m} 
    \;=\; \frac{\epsilon}{2m}.
  \]
  Since \(\epsilon\) is non-negligible, this implies that \(f\) would no longer be one-way, a contradiction. Hence our initial assumption about the existence of such an adversary \(A^\bullet\) must be false.
\end{proof}

\subsection{Unbounded DSS and Collision-Resistant Hash-Function Families}

\begin{definition}[Collision-Resistant Hash-Function Family~(crhff)]
    An~$l(m)$-sized crhff~$\{h_{\xi}\}_{\xi}$ is~defined by two polynomial-time algorithms~$Z$ and~$H$:
    \begin{itemize}
        \item $Z \colon (1^{n}, r_Z) \to \xi$, where~$\xi \in \{0, 1\}^{s(n)}$ and~$n = \poly(s(n))$.
        \item $h_{\xi} \colon \{0, 1\}^{*} \to \{0, 1\}^{l(|\xi|)}$.
        \item $H(\xi, x) = h_\xi(x)$.
        \item For~any probabilistic polynomial-time adversary~$A$, it holds~that:
            \[
                \Pr\left[A(\xi) = (y, y') \colon y \neq y' \wedge h_{\xi}(y) = h_{\xi}(y')\right] < \varepsilon(n).
            \]
    \end{itemize}
\end{definition}

\begin{exercise} ~
    \begin{enumerate}
        \item Provide~an equivalent definition of~crhff without the~algorithm $H$.
        \item Demonstrate~that crhff can~be constructed from one-way functions.
    \end{enumerate}
\end{exercise}

\begin{scheme} \label{theorem:dss_crhff}
    Assume~that~$(G, S, V)$ is~a secure one-time~$l(m)$-bounded DSS, and~$\{h_{\xi}\}_{\xi}$ is~an $l(m)$-crhff generated by~$Z$.
    Then, the~following construction provides a~secure multiple-time unbounded DSS:

    \begin{itemize}
        \item Generate~$(s, v)$ using~$G$, and generate~$\xi$ using~$Z$.
        \item Signing~key~$\sk \colon (\xi, s)$.
        \item Verification~key~$\pk \colon (\xi, v)$.
        \item $S'_{\xi, s}(\msg) = S_s(h_\xi(\msg))$.
        \item $V'_{\xi, v}(\msg, \sign) = V_v(h_\xi(\msg), \sign)$.
    \end{itemize}
\end{scheme}

\begin{exercise}
    Prove~it. (Hint: we~must break either~$(G, S, V)$ or~$\{h_\xi\}_\xi$.)
\end{exercise}

\subsection{Unbounded DSS and One-Way Hash-Function Family}


In~\Cref{theorem:dss_crhff}, we included the hash function~$\xi$ in both the signature and~the keys. 
Now, we will attempt to include~$\xi$ only in~the signature.

\begin{definition}[One-Way Hash-Function Family~(owhff)]
    An~$l(m)$-sized owhff~$\{h_{\xi}\}_{\xi}$ is defined by polynomial-time algorithms~$Z$~and~$H$ such~that:

    \begin{itemize}
        \item $Z \colon (1^{n}, r_Z) \to \xi$, where~$\xi \in \{0, 1\}^{s(n)}$~and~$n = \poly(s(n))$.
        \item $h_{\xi} \colon \{0, 1\}^{*} \to \{0, 1\}^{l(|\xi|)}$.
        \item $H(\xi, x) = h_\xi(x)$.
        \item For any probabilistic polynomial-time adversaries~$M$~and~$A$, it holds~that:
            \[
                \Pr_{y \gets M(1^{n}), \xi \gets Z(1^{n})}[A(\xi) = y' \colon y \neq y' \wedge h(y) = h(y')] < \varepsilon(n),
            \]
            where~$y$ is chosen \textbf{before}~$\xi$.
    \end{itemize}
\end{definition}

\begin{exercise} ~
    \begin{enumerate}
        \item Provide~an equivalent definition without~$H$.
        \item Show~that owhff can~be constructed from one-way functions~(owf).
    \end{enumerate}
\end{exercise}

\begin{scheme} 
    Assume~that~$(G, S, V)$ is~a secure one-time~$l(m)$-bounded DSS, and~$\{h_{\xi}\}_{\xi}$ is~an~$l(m)$-owhff generated by~$Z$.
    Then, the following construction provides~a secure multiple-time unbounded DSS:
    \begin{itemize}
        \item Generate~$(s, v)$ using~$G$.
        \item Signing~key~$\sk \colon s$.
        \item Verification~key~$\pk \colon v$.
        \item Signature: generate~$\xi$ using~$Z$, then
            \[
                S'_{\xi, s}(\msg) = (\xi, S_s(h_\xi(\msg))).
            \]
        \item $V'_{\xi, v}(\msg, (\xi, \sign)) = V_v(h_\xi(\msg), \sign)$.
    \end{itemize}
\end{scheme}

\begin{exercise}
    Prove~it.
\end{exercise}

\subsection{Unbounded Many-Times DSS}
\todo[inline]{finish}

The idea would be the following: one can sign a new public key by old public keys.
We can go even further, let $v_0, v_1$ be two fixed initial public keys.
Each time before signing we will chose either $v_0$ or $v_1$ and apply it to the old public key.
Hence, after $n - 1$ signs there is  $2^{n}$ vartiants of keys and we have some sort of the binary tree of keys.
We will each time regenerate whole path to the current node using prff instead of true randomness.

\begin{itemize}
	\item Use one-time DSS $(G, S,V)$ (w.l.o.g., $G$ and $S$ require at most $n + 3$ random bits) and prff $Z$.
	\item $(s, v) \gets G$, “root key”
	\item $\xi \gets Z$.
	\item 
\end{itemize}
