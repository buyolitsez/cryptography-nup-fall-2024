%06.11.2024
\section{Digital Signatures}

We have two participants: Alice and~Bob.
Additionally, there exists an~adversary, Charlie.
All communication between Alice and~Bob is~routed through Charlie.
Charlie has the~capability to~read, modify, and send fake messages, among other actions.
Alice intends to~sign a~message and~transmit it to~Bob.
Consequently, it must be~ensured that no entity can forge Alice's signature (even if they've seen a lot of signed messages), and that any recipient can verify that the message was indeed signed by Alice.

\begin{definition}
	A~Digital Signature Scheme~(DSS) consists~of three algorithms:
	\begin{itemize}
		\item $G \colon (1^{n}, r_g) \to (s, v)$~(key generation producing a~secret key~$s$ and a~public verifier~$v$),
		\item $S \colon (s, \msg, r_s) \to \sign$~(signing algorithm generating a~signature $\sign$ for message~$\msg$),
		\item $V \colon (v, \msg, \sign) \to \{0, 1\}$~(verification algorithm that outputs~$1$ if~$\sign$ is valid for~$\msg$, and~$0$ otherwise).
	\end{itemize}

	Moreover, the following properties are~satisfied:
	\begin{itemize}
		\item \textbf{Correctness:} For~all messages~$\msg$, it~holds that:
			\[
				\Pr_{r_g}\big[V_v(\msg, S_s(\msg)) = 0\big] = 0.
			\] 

		\item \textbf{Security:} For~any adversary~$A^\bullet$, it~holds that:
			\[
				\Pr\big[A^{S_s}(v) = (\msg, \sign) \colon V(\msg, \sign) = 1\big] < \varepsilon(n),
			\]
			where~$A^{S_s}$ can compel Alice to~sign arbitrary messages, except for the specific message~$\msg$ (utilizing the signing algorithm~$S_s$ as a~black box).
	\end{itemize}
\end{definition}

There exist various adversarial models:
\begin{itemize}
	\item The adversary can request a~signature for each message at most once: $A^{\bullet[1]}$.
	\item The adversary can request a~polynomial number of signatures: $A^{S_s, [l(n)]}$, for some polynomial function~$l(n)$.
	\item The adversary operates in an~unbounded model (general schemes).
\end{itemize}

\begin{exercise}
	Does it matter whether the algorithms~$S$~and~$V$ are~randomized?
\end{exercise}

% \begin{claim}
% 	Using a PRG $G  \colon \{0, 1\}^{n} \to  \{0, 1\}^{n + 1}$.
% 	If someone can invert $G$, then one could also break this PRG. 
% \end{claim}
% \begin{proof}
% 	To distinguish between outputs of $G$ and uniform distribution, one do the following.
% 	We take a preimage of $G$, then say that this string was generated by PRG (it may not). 
% 	Otherwise, say that its uniform.
% \end{proof}
%
% Hence, an existence of PRG implies an existence of owf.

\subsection{One-time bounded DSS}

\begin{theorem}
	Let~$f$ be a~one-way function.
	Let~$m = l(n)$ be a~polynomial.
	Then, for each~$i$ and~$k$, sample~$s_{k}^{i} \gets U_k$~(generated using~$r_g$) and~compute $v_k^{i} = f(s_{k}^{i})$.

	Specifically:
	\[
		G(1^{n}, r_g) = \big((s^{0}_{0}, s^{1}_{0}, \ldots, s^{0}_{m}, s^{1}_{m}), (v^{0}_{0}, v^{1}_{0}, \ldots, v^{0}_{m}, v^{1}_{m})\big).
	\] 
	Note that~$s_{k}^{i}$~and~$v_{k}^{i}$ are strings, not individual bits.
	Using this setup, one can sign a~message $\beta_1 \circ \ldots \circ \beta_m$ as:
	\[
		S_s(\beta_1 \circ \ldots \circ \beta_m) = (s_1^{\beta_1}, \ldots, s_m^{\beta_m}).
	\] 
	To verify a~signature $\sign$ for a~message $\msg$, the~verification algorithm~$V(\msg, \sign)$ checks that, for all~$i \in [m]$, the following holds:
	\[
		f(\sign_i) = v_i^{\beta_i}.
	\]

	Thus, the~tuple $(G, S, V)$ constitutes a~Digital Signature Scheme~(DSS).
\end{theorem}

\begin{proof}
	Assume there exists an adversary~$A^{\bullet}$ for the given DSS.
	We will demonstrate how to invert~$f$.
	Let~$y$ be a~value for which we aim to find~$f^{-1}(y)$.
	Randomly choose~$k \in [m]$~and~$b \in \{0, 1\}$. Then, generate:
	\[
		G(1^{n}, r_g) = \big((s^{0}_{0}, s^{1}_{0}, \ldots, \hcancel[red]{s_{k}}^{b}, \ldots, s^{0}_{m}, s^{1}_{m}), (v^{0}_{0}, v^{1}_{0}, \ldots, y, \ldots, v^{0}_{m}, v^{1}_{m})\big).
	\] 
	Here, we replace~$v_{k}^{b}$ with~$y$~and remove~$s_{k}^{b}$ from the signing key.

	Next, we query the adversary to sign a~random message~$m$.
	The adversary may use the signing oracle as a~black box to sign some other message~$x$.
	If~$x_k \neq b$, the adversary can proceed as usual, and we are able to invert~$f$.
	This scenario occurs with probability~$\frac{1}{2}$, as~$b$ is chosen randomly.
	However, in this case, we cannot invert~$f$ always, as it depends on the information provided by the signing oracle.
	I.e. we can invert $f$ only if  $z_{k} \neq  x_k$, it occurs with probability at least~$\frac{1}{m}$.
	Therefore, by leveraging the adversary's capabilities, we can invert~$f$ with non-negligible probability.
\end{proof}

\subsection{Unbounded DSS and Collision-Resistant Hash-Function Families}

\begin{definition}[Collision-Resistant Hash-Function Family~(crhff)]
    An~$l(m)$-sized crhff~$\{h_{\xi}\}_{\xi}$ is~defined by two polynomial-time algorithms~$Z$ and~$H$:
    \begin{itemize}
        \item $Z \colon (1^{n}, r_Z) \to \xi$, where~$\xi \in \{0, 1\}^{s(n)}$ and~$n = \poly(s(n))$.
        \item $h_{\xi} \colon \{0, 1\}^{*} \to \{0, 1\}^{l(|\xi|)}$.
        \item $H(\xi, x) = h_\xi(x)$.
        \item For~any probabilistic polynomial-time adversary~$A$, it holds~that:
            \[
                \Pr\left[A(\xi) = (y, y') \colon y \neq y' \wedge h_{\xi}(y) = h_{\xi}(y')\right] < \varepsilon(n).
            \]
    \end{itemize}
\end{definition}

\begin{exercise} ~
    \begin{enumerate}
        \item Provide~an equivalent definition of~crhff without the~algorithm $H$.
        \item Demonstrate~that crhff can~be constructed from one-way functions.
    \end{enumerate}
\end{exercise}

\begin{theorem} \label{theorem:dss_crhff}
    Assume~that~$(G, S, V)$ is~a secure one-time~$l(m)$-bounded DSS, and~$\{h_{\xi}\}_{\xi}$ is~an $l(m)$-crhff generated by~$Z$.
    Then, the~following construction provides a~secure multiple-time unbounded DSS:

    \begin{itemize}
        \item Generate~$(s, v)$ using~$G$, and generate~$\xi$ using~$Z$.
        \item Signing~key~$\sk \colon (\xi, s)$.
        \item Verification~key~$\pk \colon (\xi, v)$.
        \item $S'_{\xi, s}(\msg) = S_s(h_\xi(\msg))$.
        \item $V'_{\xi, v}(\msg, \sign) = V_v(h_\xi(\msg), \sign)$.
    \end{itemize}
\end{theorem}

\begin{exercise}
    Prove~it. (Hint: we~must break either~$(G, S, V)$ or~$\{h_\xi\}_\xi$.)
\end{exercise}

\subsection{Unbounded DSS and One-Way Hash-Function Family (owhff)}


In~\Cref{theorem:dss_crhff}, we included the hash function~$\xi$ in both the signature and~the keys. 
Now, we will attempt to include~$\xi$ only in~the signature.

\begin{definition}[One-Way Hash-Function Family~(owhff)]
    An~$l(m)$-sized owhff~$\{h_{\xi}\}_{\xi}$ is defined by polynomial-time algorithms~$Z$~and~$H$ such~that:

    \begin{itemize}
        \item $Z \colon (1^{n}, r_Z) \to \xi$, where~$\xi \in \{0, 1\}^{s(n)}$~and~$n = \poly(s(n))$.
        \item $h_{\xi} \colon \{0, 1\}^{*} \to \{0, 1\}^{l(|\xi|)}$.
        \item $H(\xi, x) = h_\xi(x)$.
        \item For any probabilistic polynomial-time adversaries~$M$~and~$A$, it holds~that:
            \[
                \Pr_{y \gets M(1^{n}), \xi \gets Z(1^{n})}[A(\xi) = y' \colon y \neq y' \wedge h(y) = h(y')] < \varepsilon(n),
            \]
            where~$y$ is chosen \textbf{before}~$\xi$.
    \end{itemize}
\end{definition}

\begin{exercise} ~
    \begin{enumerate}
        \item Provide~an equivalent definition without~$H$.
        \item Show~that owhff can~be constructed from one-way functions~(owf).
    \end{enumerate}
\end{exercise}

\begin{theorem} 
    Assume~that~$(G, S, V)$ is~a secure one-time~$l(m)$-bounded DSS, and~$\{h_{\xi}\}_{\xi}$ is~an~$l(m)$-owhff generated by~$Z$.
    Then, the following construction provides~a secure multiple-time unbounded DSS:
    \begin{itemize}
        \item Generate~$(s, v)$ using~$G$.
        \item Signing~key~$\sk \colon s$.
        \item Verification~key~$\pk \colon v$.
        \item Signature: generate~$\xi$ using~$Z$, then
            \[
                S'_{\xi, s}(\msg) = (\xi, S_s(h_\xi(\msg))).
            \]
        \item $V'_{\xi, v}(\msg, (\xi, \sign)) = V_v(h_\xi(\msg), \sign)$.
    \end{itemize}
\end{theorem}

\begin{exercise}
    Prove~it.
\end{exercise}

\subsection{Unbounded Many-Times DSS}
\todo[inline]{finish}

The idea would be the following: one can sign a new public key by old public keys.
We can go even further, let $v_0, v_1$ be two fixed initial public keys.
Each time before signing we will chose either $v_0$ or $v_1$ and apply it to the old public key.
Hence, after $n - 1$ signs there is  $2^{n}$ vartiants of keys and we have some sort of the binary tree of keys.
We will each time regenerate whole path to the current node using prff instead of true randomness.

\begin{itemize}
	\item Use one-time DSS $(G, S,V)$ (w.l.o.g., $G$ and $S$ require at most $n + 3$ random bits) and prff $Z$.
	\item $(s, v) \gets G$, “root key”
	\item $\xi \gets Z$.
	\item 
\end{itemize}
