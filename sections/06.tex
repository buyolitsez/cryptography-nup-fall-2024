%06.11.2024
\section{Digital Signatures}

We have two participants: Alice and~Bob.
Additionally, there exists an~adversary, Charlie.
All communication between Alice and~Bob is~routed through Charlie.
Charlie has the~capability to~read, modify, and send fake messages, among other actions.
Alice intends to~sign a~message and~transmit it to~Bob.
Consequently, it must be~ensured that no entity can forge Alice's signature (even if they've seen a lot of signed messages), and that any recipient can verify that the message was indeed signed by Alice.

\begin{definition}
	A~Digital Signature Scheme~(DSS) consists~of three algorithms:
	\begin{itemize}
		\item $G \colon (1^{n}, r_g) \to (s, v)$~(key generation producing a~secret key~$s$ and a~public verifier~$v$),
		\item $S \colon (s, \msg, r_s) \to \sign$~(signing algorithm generating a~signature $\sign$ for message~$\msg$),
		\item $V \colon (v, \msg, \sign) \to \{0, 1\}$~(verification algorithm that outputs~$1$ if~$\sign$ is valid for~$\msg$, and~$0$ otherwise).
	\end{itemize}

	Moreover, the following properties are~satisfied:
	\begin{itemize}
		\item \textbf{Correctness:} For~all messages~$\msg$, it~holds that:
			\[
				\Pr_{r_g}\big[V_v(\msg, S_s(\msg)) = 0\big] = 0.
			\] 

		\item \textbf{Security:} For~any adversary~$A^\bullet$, it~holds that:
			\[
				\Pr\big[A^{S_s}(v) = (\msg, \sign) \colon V(\msg, \sign) = 1\big] < \varepsilon(n),
			\]
			where~$A^{S_s}$ can compel Alice to~sign arbitrary messages, except for the specific message~$\msg$ (utilizing the signing algorithm~$S_s$ as a~black box).
	\end{itemize}
\end{definition}

There exist various adversarial models:
\begin{itemize}
	\item The adversary can request a~signature for each message at most once: $A^{\bullet[1]}$.
	\item The adversary can request a~polynomial number of signatures: $A^{S_s, [l(n)]}$, for some polynomial function~$l(n)$.
	\item The adversary operates in an~unbounded model (general schemes).
\end{itemize}

\begin{exercise}
	Does it matter whether the algorithms~$S$~and~$V$ are~randomized?
\end{exercise}

% \begin{claim}
% 	Using a PRG $G  \colon \{0, 1\}^{n} \to  \{0, 1\}^{n + 1}$.
% 	If someone can invert $G$, then one could also break this PRG. 
% \end{claim}
% \begin{proof}
% 	To distinguish between outputs of $G$ and uniform distribution, one do the following.
% 	We take a preimage of $G$, then say that this string was generated by PRG (it may not). 
% 	Otherwise, say that its uniform.
% \end{proof}
%
% Hence, an existence of PRG implies an existence of owf.

\subsection{One-time bounded DSS}

\begin{scheme}
	Let~$f$ be a~one-way function.
	Let~$m = l(n)$ be a~polynomial.
	Then, for each~$i$ and~$k$, sample~$s_{k}^{i} \gets U_k$~(generated using~$r_g$) and~compute $v_k^{i} = f(s_{k}^{i})$.

	Specifically:
	\[
		G(1^{n}, r_g) = \big((s^{0}_{0}, s^{1}_{0}, \ldots, s^{0}_{m}, s^{1}_{m}), (v^{0}_{0}, v^{1}_{0}, \ldots, v^{0}_{m}, v^{1}_{m})\big).
	\] 
	Note that~$s_{k}^{i}$~and~$v_{k}^{i}$ are strings, not individual bits.
	Using this setup, one can sign a~message $\beta_1 \circ \ldots \circ \beta_m$ as:
	\[
		S_s(\beta_1 \circ \ldots \circ \beta_m) = (s_1^{\beta_1}, \ldots, s_m^{\beta_m}).
	\] 
	To verify a~signature $\sign$ for a~message $\msg$, the~verification algorithm~$V(\msg, \sign)$ checks that, for all~$i \in [m]$, the following holds:
	\[
		f(\sign_i) = v_i^{\beta_i}.
	\]

	Thus, the~tuple $(G, S, V)$ constitutes a~Digital Signature Scheme~(DSS).
\end{scheme}
\begin{lemma}
    This scheme is secure.
\end{lemma}
 
\begin{proof}
  Suppose there exists an adversary \(A^\bullet\) that breaks the given digital signature scheme (DSS) with a non-negligible advantage \(\epsilon\). We will show how to use \(A^\bullet\) to invert the one-way function \(f\) with non-negligible probability, contradicting the one-wayness of \(f\).

  Let \(y\) be an arbitrary value for which we wish to find \(f^{-1}(y)\). We randomly choose an index \(k \in [m]\) and a bit \(b \in \{0,1\}\). Then we generate 
  \[
    G\bigl(1^{n}, r_g\bigr) 
    \;=\; 
    \bigl( (s^{0}_{0}, s^{1}_{0}, \dots, s^{0}_{m}, s^{1}_{m}),\;
           (v^{0}_{0}, v^{1}_{0}, \dots, v^{0}_{m}, v^{1}_{m}) \bigr),
  \]
  but \emph{replace} \(v_{k}^{b}\) with our target value \(y\). In other words, we “hide” \(y\) in one position of the public key.

  We give the adversary \(A^\bullet\) the modified public key \(\{v_{i}^{j}\}\) (where one element \(v_{k}^{b}\) has been replaced by \(y\)) and the corresponding secret key \(\{s_{i}^{j}\}\). The adversary then makes (adaptive) signing queries. Denote by \(M'\) the message (in \(\{0,1\}^m\)) that \(A^\bullet\) asks us to sign at some point.

  Let \(M'_k\) be the \(k\)-th bit of \(M'\).
  - If \(M'_k = b\), we must \textbf{abort}, since we cannot produce a valid signature (the required preimage for \(v_{k}^{b}\) is unknown; it was replaced by \(y\)).
  
  - If \(M'_k \neq b\), we \emph{can} generate a valid signature, because we do know all necessary preimages (including \(s_{k}^{1-b}\)).

  The key observation is that \(A^\bullet\) does not know which index \(k\) we selected or which bit \(b\) we used to “hide” \(y\). Hence the probability that \(A^\bullet\) picks a message \(M'\) with \(M'_k = b\) is \(1/2\), and similarly \(M'_k \neq b\) with probability \(1/2\). Thus, we do not abort with probability \(1/2\).

  Next, assume that the adversary eventually \emph{forges} a signature (which happens with probability at least \(\epsilon\)). A successful forgery must include a correct preimage for one of the public-key elements \(v_{i}^{j}\). If it happens that the forged preimage corresponds to \(v_{k}^{b} = y\), we recover \(f^{-1}(y)\) and succeed in inverting \(f\).

  To estimate the overall probability of success, note the following:

  - We do \emph{not} abort with probability \(1/2\).

  - The adversary forges successfully with probability at least \(\epsilon\).

  - Among the \(2m\) components \(\{v_{i}^j\}\), there is exactly one “special” element \(v_{k}^{b} = y\). The probability that the adversary’s forgery reveals the preimage of \(y\) (i.e., targets precisely \((k,b)\)) is at least \(1/m\).

  Multiplying these factors together, our overall probability of recovering \(f^{-1}(y)\) is at least
  \[
    \frac{1}{2} \;\times\; \epsilon \;\times\; \frac{1}{m} 
    \;=\; \frac{\epsilon}{2m}.
  \]
  Since \(\epsilon\) is non-negligible, this implies that \(f\) would no longer be one-way, a contradiction. Hence our initial assumption about the existence of such an adversary \(A^\bullet\) must be false.
\end{proof}

\subsection{Unbounded DSS and Collision-Resistant Hash-Function Families}

\begin{definition}[Collision-Resistant Hash-Function Family~(crhff)]
    An~$l(m)$-sized crhff~$\{h_{\xi}\}_{\xi}$ is~defined by two polynomial-time algorithms~$Z$ and~$H$:
    \begin{itemize}
        \item $Z \colon (1^{n}, r_Z) \to \xi$, where~$\xi \in \{0, 1\}^{s(n)}$ and~$n = \poly(s(n))$.
        \item $h_{\xi} \colon \{0, 1\}^{*} \to \{0, 1\}^{l(|\xi|)}$.
        \item $H(\xi, x) = h_\xi(x)$.
        \item For~any probabilistic polynomial-time adversary~$A$, it holds~that:
            \[
                \Pr\left[A(\xi) = (y, y') \colon y \neq y' \wedge h_{\xi}(y) = h_{\xi}(y')\right] < \varepsilon(n).
            \]
    \end{itemize}
\end{definition}

\begin{exercise} ~
    \begin{enumerate}
        \item Provide~an equivalent definition of~crhff without the~algorithm $H$.
        \item Demonstrate~that crhff can~be constructed from one-way functions.
    \end{enumerate}
\end{exercise}

\begin{scheme} \label{theorem:dss_crhff}
    Assume~that~$(G, S, V)$ is~a secure one-time~$l(m)$-bounded DSS, and~$\{h_{\xi}\}_{\xi}$ is~an $l(m)$-crhff generated by~$Z$.
    Then, the~following construction provides a~secure multiple-time unbounded DSS:

    \begin{itemize}
        \item Generate~$(s, v)$ using~$G$, and generate~$\xi$ using~$Z$.
        \item Signing~key~$\sk \colon (\xi, s)$.
        \item Verification~key~$\pk \colon (\xi, v)$.
        \item $S'_{\xi, s}(\msg) = S_s(h_\xi(\msg))$.
        \item $V'_{\xi, v}(\msg, \sign) = V_v(h_\xi(\msg), \sign)$.
    \end{itemize}
\end{scheme}

\begin{exercise}
    Prove~it. (Hint: we~must break either~$(G, S, V)$ or~$\{h_\xi\}_\xi$.)
\end{exercise}

\subsection{Unbounded DSS and One-Way Hash-Function Family}


In~\Cref{theorem:dss_crhff}, we included the hash function~$\xi$ in both the signature and~the keys. 
Now, we will attempt to include~$\xi$ only in~the signature.

\begin{definition}[One-Way Hash-Function Family~(owhff)]
    An~$l(m)$-sized owhff~$\{h_{\xi}\}_{\xi}$ is defined by polynomial-time algorithms~$Z$~and~$H$ such~that:

    \begin{itemize}
        \item $Z \colon (1^{n}, r_Z) \to \xi$, where~$\xi \in \{0, 1\}^{s(n)}$~and~$n = \poly(s(n))$.
        \item $h_{\xi} \colon \{0, 1\}^{*} \to \{0, 1\}^{l(|\xi|)}$.
        \item $H(\xi, x) = h_\xi(x)$.
        \item For any probabilistic polynomial-time adversaries~$M$~and~$A$, it holds~that:
            \[
                \Pr_{y \gets M(1^{n}), \xi \gets Z(1^{n})}[A(\xi) = y' \colon y \neq y' \wedge h(y) = h(y')] < \varepsilon(n),
            \]
            where~$y$ is chosen \textbf{before}~$\xi$.
    \end{itemize}
\end{definition}

\begin{exercise} ~
    \begin{enumerate}
        \item Provide~an equivalent definition without~$H$.
        \item Show~that owhff can~be constructed from one-way functions~(owf).
    \end{enumerate}
\end{exercise}

\begin{scheme} 
    Assume~that~$(G, S, V)$ is~a secure one-time~$l(m)$-bounded DSS, and~$\{h_{\xi}\}_{\xi}$ is~an~$l(m)$-owhff generated by~$Z$.
    Then, the following construction provides~a secure multiple-time unbounded DSS:
    \begin{itemize}
        \item Generate~$(s, v)$ using~$G$.
        \item Signing~key~$\sk \colon s$.
        \item Verification~key~$\pk \colon v$.
        \item Signature: generate~$\xi$ using~$Z$, then
            \[
                S'_{\xi, s}(\msg) = (\xi, S_s(h_\xi(\msg))).
            \]
        \item $V'_{\xi, v}(\msg, (\xi, \sign)) = V_v(h_\xi(\msg), \sign)$.
    \end{itemize}
\end{scheme}

\begin{exercise}
    Prove~it.
\end{exercise}

\subsection{Unbounded Many-Times DSS}
\todo[inline]{finish}

\section{Many-Time DSS - Idea}

Here we define the many-time secure signature property, which is stronger than the one-time secure signature property. Similarly, we can define the many-time signature game as follows.

\textbf{Definition} For a signature scheme $\Pi = (Gen, Sign, Verify)$, the many-time signature game $\text{Sig-game}^{q-time}_{A,C,\Pi} (k)$ is defined using a challenger $C$ and an adversary $A$. In this game:

\begin{enumerate}
    \item $C$ uses $Gen(1^k; r)$ to generate a pair of keys $(vk, sk)$,
    \item $C$ sends the key $vk$ to $A$,
    \item $A$ sends $q$ messages $m_1, \dots, m_q \in M$ to $C$,
    \item $C$ generates $q$ signatures $\sigma_1 = Sign(m_1, sk), \dots, \sigma_q = Sign(m_q, sk)$,
    \item $A$ outputs a message-signature pair $(m, \sigma)$ such that $m \notin \{m_1, \dots, m_q\}$,
    \item The output of the game is 1 if $Verify(m, \sigma, vk) = 1$, and 0 otherwise.
\end{enumerate}

A stronger alternative game allows the adversary to query a message, obtain its signature, and repeat this process $q$ times. We say the adversary wins the game if they can produce a new message-signature pair $(m, \sigma)$ such that $Verify(m, \sigma, vk) = 1$ and $m \notin \{m_1, \dots, m_q\}$, i.e., $\text{Sig-game}^{q-time}_{A,C,\Pi} (k)$ outputs 1. Formally, we have:

\textbf{Definition} A signature scheme $\Pi = (Gen, Sign, Verify)$ is many-time secure if for all PPT adversaries $A$ and any number of queries $q$, there exists a negligible function $\epsilon(k)$ such that:

\[
Pr[\text{Sig-game}^{q-time}_{A,C,\Pi} = 1] \leq \epsilon(k).
\]

Additionally, we have the strong many-time secure signature property, where we only require the adversary to output the message-signature pair $(m, \sigma)$ such that $(m, \sigma) \notin \{(m_1, \sigma_1), \dots, (m_q, \sigma_q)\}$. 

Since we have defined the many-time secure signature property, we can also easily see that the Lamport one-time signature scheme is not many-time secure. In fact, it is not even two-time secure. The adversary can send $m_1 = 00\dots0$ and $m_2 = 11\dots1$ to the challenger. Then the adversary simply extracts the secret signing key $sk$ from the challenger's response, where $\sigma_1 = (r_{1,0}, r_{2,0}, \dots, r_{n,0})$ and $\sigma_2 = (r_{1,1}, r_{2,1}, \dots, r_{n,1})$.

\section{Many-Time DSS: Construction}

From one-time DSS and pseudorandom function family.

\begin{itemize}
    \item Use one-time $(G, S, V)$ (w.l.o.g., $G$ and $S$ require at most $n + 3$ random bits) and pseudorandom function $Z$:
    \begin{itemize}
        \item $(s, v) \leftarrow G$, \textit{"root key"}
        \item $\zeta \leftarrow Z$
    \end{itemize}
    \item \textbf{Signing key} $sk: (\zeta, s)$
    \item \textbf{Verification key} $pk: v$
\end{itemize}

\subsection{Signing Algorithm}

\begin{itemize}
    \item Select path $\sigma = \sigma_1 \dots \sigma_n \in \{0,1\}^n$ from the root key to a leaf either at random or using $\zeta(110\xi(\text{msg}))$.
    \item Generate all keys (both left and right) for prefixes of this path $(i = 0,1,\dots,n-1)$:
    \begin{align*}
        (s_{\sigma'0}, v_{\sigma'0}) &\leftarrow G(1^n, \zeta(10^{n-i+1}\sigma'0)) \quad \text{for } \sigma' = \sigma_1\dots\sigma_i,\\
        (s_{\sigma'1}, v_{\sigma'1}) &\leftarrow G(1^n, \zeta(10^{n-i+1}\sigma'1)) \quad \text{for } \sigma' = \sigma_1\dots\sigma_i.
    \end{align*}
\end{itemize}

Given keys $(s_{\sigma}, v_{\sigma})$:

\[
S_{s_{\sigma}}(\text{msg}, \zeta(00\dots\sigma)).
\]

Keys are signed sequentially:

\[
(v_0, v_1, S_{s_0}(v_0)), (v_{\sigma_1 0}, v_{\sigma_1 1}, S_{s_{\sigma_1}}(v_{\sigma_1 0})), \dots
\]

\[
(v_{\sigma_1\dots\sigma_{n-1} 0}, v_{\sigma_1\dots\sigma_{n-1} 1}, S_{s_{\sigma_1\dots\sigma_{n-1}}}(v_{\sigma_1\dots\sigma_{n-1} 0}), \zeta(00^3 \sigma_1\dots\sigma_{n-1})).
\]


A digital signature scheme is correct if a signature generated by a valid signing algorithm is always accepted by the verification algorithm:
\begin{equation}
    \forall (sk, pk) \leftarrow \text{KeyGen}(1^\lambda), \forall m, \sigma: \sigma = \text{Sign}(sk, m) \Rightarrow \text{Verify}(pk, m, \sigma) = 1.
\end{equation}

This means that a correctly generated signature should always pass verification.

\section{Proof of Correctness}

\subsection{Step 1: Key Generation and Signature Path}
Many-Time DSS constructs keys recursively along a path from a root key to a leaf in a binary tree. The keys are generated as follows:
\begin{equation}
    (s_{\sigma'0}, v_{\sigma'0}) \gets G(1^n, \zeta(10^{n-i+1} \sigma'0))
\end{equation}
\begin{equation}
    (s_{\sigma'1}, v_{\sigma'1}) \gets G(1^n, \zeta(10^{n-i+1} \sigma'1))
\end{equation}
for all prefixes \( \sigma' \) of the chosen path \( \sigma \).

\subsection{Step 2: Recursive Signature Verification}
Each node key in the path is verified sequentially using a one-time signature:
\begin{equation}
    S_{s_{\sigma_1}} (v_0), S_{s_{\sigma_1 \sigma_2}} (v_{\sigma_1}), \dots, S_{s_{\sigma_1 \dots \sigma_{n-1}}} (v_{\sigma_1 \dots \sigma_{n-2}})
\end{equation}

This ensures that each signature in the sequence is valid and authenticates the next verification key.

\subsection{Step 3: Final Signature Verification}
The final signature \( S_{\sigma}(msg, \zeta(00\dots\sigma)) \) is checked using the same deterministic randomness function \( \zeta \). Since the same deterministic key generation process is used at each step, verification proceeds as follows:

\begin{itemize}
    \item The verification algorithm starts with \( v_0 \) and checks each successive signature.
    \item If all intermediate signatures are valid, the final message signature is verified.
\end{itemize}

\subsection{Step 4: Conclusion}
Since each step in the verification process is based on deterministic key derivation and sequential signature verification, correctness follows:
\begin{equation}
    \text{Verify}(pk, m, \text{Sign}(sk, m)) = 1
\end{equation}
Thus, a correctly generated signature will always be accepted, proving the correctness of Many-Time DSS.


\section{A Memory-Dependent Signature Scheme}

Authentication-Trees can be considered as one of the ways to build a Many-Time DSS.

Let $(G, S, V)$ be a one-time signature scheme. Consider the following memory-dependent signature scheme, $(G', S', V')$, with $G' = G$. On security parameter $n$, the scheme uses a full binary tree of depth $n$. Each of the nodes in this tree is labeled by a binary string so that the root is labeled by the empty string, denoted $\lambda$, and the left (resp., right) child of a node labeled $x$ is labeled by $x0$ (resp., $x1$). Here we refer to the current state of the signing process as a record.

\subsection{Initiating the Scheme}
To initiate the scheme, on security parameter $n$, we invoke $G(1^n)$ and let $(s, v) \leftarrow G(1^n)$. We record $(s, v)$ as the key-pair associated with the root and output $v$ as the (public) verification key.

\subsection{Signing Algorithm $S'$}
To sign a new document, denoted $\alpha$, we first allocate an unused leaf. Let $\sigma_1 \dots \sigma_n$ be the label of this leaf. For example, we may keep a counter of the number of documents signed and determine $\sigma_1 \dots \sigma_n$ according to the counter value (e.g., if the counter value is $c$, then we use the $c$-th string in lexicographic order).

Next, for every $i = 1, ..., n$ and every $\tau \in \{0,1\}$, we try to retrieve from our record the key-pair associated with the node labeled $\sigma_1 \dots \sigma_{i-1}\tau$. If such a pair is not found, we generate it by invoking $G(1^n)$ and store it for future use:
\[
(s_{\sigma_1 \dots \sigma_{i-1}\tau}, v_{\sigma_1 \dots \sigma_{i-1}\tau}) \leftarrow G(1^n).
\]

Next, for every $i = 1, ..., n$, we try to retrieve from our record a signature to the string $v_{\sigma_1 \dots \sigma_{i-1}0} v_{\sigma_1 \dots \sigma_{i-1}1}$ relative to the signing-key $s_{\sigma_1 \dots \sigma_{i-1}}$. If such a signature is not found, we generate it by invoking $S$ and store it for future use:
\[
S_{s_{\sigma_1 \dots \sigma_{i-1}}}(v_{\sigma_1 \dots \sigma_{i-1}0}, v_{\sigma_1 \dots \sigma_{i-1}1}).
\]

We define:
\[
\text{auth}_{\sigma_1 \dots \sigma_{i-1}} = (v_{\sigma_1 \dots \sigma_{i-1}0}, v_{\sigma_1 \dots \sigma_{i-1}1}, S_{s_{\sigma_1 \dots \sigma_{i-1}}}(v_{\sigma_1 \dots \sigma_{i-1}0}, v_{\sigma_1 \dots \sigma_{i-1}1})).
\]

Finally, the signature of $\alpha$ consists of:
\[
(\sigma_1 \dots \sigma_n, \text{auth}_\lambda, \text{auth}_{\sigma_1}, ..., \text{auth}_{\sigma_1 \dots \sigma_{n-1}}, S_{s_{\sigma_1 \dots \sigma_n}}(\alpha)).
\]

